package LazyDoubleCheked;

public class Singleton {
    private static volatile Singleton instance;

    // Приватный конструктор предотвращает создание экземпляра класса извне
    private Singleton() {}

    public static Singleton getInstance() {
        // Первая проверка без синхронизации
        if (instance == null) {
            synchronized (Singleton.class) {
                // Вторая проверка с синхронизацией
                if (instance == null) {
                    instance = new Singleton(); // создание экземпляра
                }
            }
        }
        return instance;
    }
}


//Lazy Double Checked Locking  — это один из способов реализации паттерна Singleton, который позволяет создавать экземпляр класса только по мере необходимости (лениво) и минимизировать накладные расходы, связанные с синхронизацией потоков.
//
//Принципы работы
//Ленивая инициализация: Экземпляр класса создается только при первом обращении к нему.
//Двойная проверка: Перед блокировкой потока происходит проверка, существует ли экземпляр, что позволяет избежать ненужной синхронизации, если экземпляр уже создан.
// Преимущества
// Эффективность: Снижение накладных расходов на синхронизацию, поскольку блокировка происходит только при необходимости.
//Безопасность потоков: Правильная реализация гарантирует, что экземпляр будет создан только один раз, даже если несколько потоков обращаются к getInstance() одновременно.
//Недостатки
//Сложность: Код становится сложнее для понимания и поддержки из-за двойной проверки и необходимости использования volatile.
//Проблемы с производительностью: Если экземпляр уже создан, первое обращение может быть медленным из-за синхронизации.